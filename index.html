<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Guitar Sheet Builder — v1</title>
    <style>
        :root {
            --bg: #0f172a;
            --fg: #e5e7eb;
            --muted: #94a3b8;
            --accent: #22c55e;
            --card: #111827;
            --br: 14px;
            --scale: 1;
        }

        @media screen {

            html,
            body {
                height: 100%;
            }
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            background: var(--bg);
            color: var(--fg);
            line-height: 1.5;
        }

        header#toolbar {
            position: relative;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            background: linear-gradient(180deg, #0b1220, #0a0f1c);
            border-bottom: 1px solid #1f2937;
        }

        .brand {
            font-weight: 700;
            letter-spacing: 0.2px;
        }

        .subtle {
            color: var(--muted);
            font-size: 0.9rem;
        }

        .spacer {
            flex: 1;
        }

        .file-box {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: #0b1322;
            border: 1px solid #243046;
            padding: 8px 10px;
            border-radius: var(--br);
        }

        input[type="file"] {
            color: var(--fg);
        }

        select {
            background: #1e293b;
            color: var(--fg);
            border: 1px solid #334155;
            padding: 2px 6px;
            font-size: 1rem;
            border-radius: 6px;
        }

        button {
            background: #1e293b;
            color: var(--fg);
            border: 1px solid #334155;
            padding: 2px 8px;
            font-size: 1rem;
            border-radius: 6px;
            cursor: pointer;
        }

main#app {
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 16px;
}


        .hint {
            color: var(--muted);
            font-size: 0.95rem;
            margin: 4px 0 18px;
        }

        .meta-header {
            font-size: 1rem;
            line-height: 1.4;
            margin-bottom: 20px;
            padding: 0 8px;
        }


        .meta-header p {
            margin: 4px 0;
        }

        .chunk {
            margin: 18px 0;
            padding: 0;
            border: none;
            background: none;
        }

        .chunk h2 {
            margin: 0 0 10px;
            font-size: calc(1.05rem * var(--scale));
            color: #cbd5e1;
        }

        .line-wrapper {
            width: 100%;
        }

        .line-wrapper>.line-table {
            zoom: var(--scale);
        }

        .line-table {
            border-collapse: separate;
            border-spacing: 0 0;
            table-layout: auto;
            margin: 2px 0 6px;
        }

        .line-table td {
            padding: 0 .4ch;
            vertical-align: bottom;
        }

        .line-table td>span {
            white-space: nowrap;
            display: inline-block;
        }

        .note-row td {
            height: 1.4em;
            color: #facc15;
        }

        .word-row td {
            height: 1.6em;
        }

        .line-table+.line-table {
            margin-top: 4px;
        }

        .chunk+.chunk {
            margin-top: 22px;
        }

        @media print {
            @page {
                margin: 12mm;
            }


            .chunk h2 {
                color: black !important;
                font-style: italic;
            }


            body {
                counter-reset: page 1;
            }

            .page-number-tag::after {
                content: counter(page);
            }

            header#toolbar {
                display: none !important;
            }

            .meta-header {
                margin-bottom: 0;
                background: white;
                color: black;
                font-size: 1rem;
                text-align: right;
                page-break-after: avoid;
            }


            .meta-header p {
                margin: 2mm 0;
            }

            body {
                background: white;
                color: black;
            }

            .chunk {
                page-break-inside: avoid;
                break-inside: avoid;
                page-break-after: auto;
                display: block;
            }

            .note-row td {
                color: #000;
                font-weight: bold;
            }
        }
    </style>
</head>

<body>
    <header id="toolbar" role="banner">
        <div class="brand">Guitar Sheet Builder</div>
        <div class="subtle">v1 — upload a .txt file to render</div>
        <div class="spacer"></div>



        <div class="file-box">
            <button id="zoomOutBtn" type="button">–</button>
            <span style="min-width: 2ch; text-align: center;" id="zoomDisplay">100%</span>
            <button id="zoomInBtn" type="button">+</button>
        </div>

        <div class="file-box">
            <label for="modeSelect">Mode:</label>
            <select id="modeSelect">
                <option value="guitar" selected>Guitar</option>
                <option value="words">Words Only</option>
                <option value="bass">Bass</option>
            </select>
        </div>

        <div class="file-box">
            <label for="transposeSelect">Key:</label>
            <select id="transposeSelect">
                <option value="">(no transpose)</option>
                <option value="C">C</option>
                <option value="Db">Db</option>
                <option value="D">D</option>
                <option value="Eb">Eb</option>
                <option value="E">E</option>
                <option value="F">F</option>
                <option value="Gb">Gb</option>
                <option value="G">G</option>
                <option value="Ab">Ab</option>
                <option value="A">A</option>
                <option value="Bb">Bb</option>
                <option value="B">B</option>
            </select>
        </div>


        <label class="file-box">
            <span>Upload text</span>
            <input id="fileInput" type="file" accept=".txt,text/plain" />
        </label>
    </header>



    <main id="app" role="main">
        <div id="placeholder" class="hint">No file loaded yet. Upload a text file using the control above.</div>
        <div id="metaHeader" class="meta-header"></div>
        <div id="output"></div>
    </main>

    <script>
        let scale = 1;
        const minScale = 0.5;
        const maxScale = 2;
        const scaleStep = 0.1;
        const KNOWN_METADATA_KEYS = ["title", "author", "ccli", "key", "bpm", "timing", "roadmap"];

        function getDisplayName(raw) {
            const lower = raw.toLowerCase();

            const labelMap = {
                'v': 'Verse',
                'c': 'Chorus',
                'b': 'Bridge',
                'pc': 'Pre-Chorus'
            };

            const match = lower.match(/^([a-z]+)(\d*)$/);

            if (match) {
                const prefix = match[1];
                const number = match[2];
                const label = labelMap[prefix] || raw;
                return number ? `${label} ${number}` : label;
            }

            // fallback: Title Case the input
            return raw.replace(/(^|\s)\S/g, c => c.toUpperCase());
        }


        const updateScale = () => {
            document.documentElement.style.setProperty('--scale', scale.toFixed(2));
            document.getElementById('zoomDisplay').textContent = Math.round(scale * 100) + '%';
        };

        document.getElementById('zoomInBtn').addEventListener('click', () => {
            if (scale < maxScale) {
                scale += scaleStep;
                updateScale();
            }
        });

        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            if (scale > minScale) {
                scale -= scaleStep;
                updateScale();
            }
        });

        updateScale();

        // Mode logic
        let mode = 'guitar';
        let transposeKey = '';
        let lastLoadedText = '';
        let userHasSetTranspose = false;
        let userPrefersFlats = true;

        document.getElementById('modeSelect').addEventListener('change', (e) => {
            mode = e.target.value;
            renderDocument(lastLoadedText);
        });

        document.getElementById('transposeSelect').addEventListener('change', (e) => {
            transposeKey = e.target.value;
            userHasSetTranspose = true;
            renderDocument(lastLoadedText);
        });



        function parseChunksFromLabeledText(raw) {
            const text = raw.replace(/\r\n/g, "\n").replace(/\r/g, "\n").trim();
            if (!text) return [];

            const lines = text.split('\n');
            const chunks = [];
            let currentChunk = { name: null, lines: [] };

            for (const line of lines) {
                const trimmed = line.trim();
                const isChunkLabel = /^\[\![^\]]+\]$/.test(trimmed);

                if (isChunkLabel) {
                    if (currentChunk.lines.length > 0 || currentChunk.name !== null) {
                        chunks.push(currentChunk);
                    }
                    currentChunk = {
                        name: trimmed.slice(2, -1).trim(),
                        lines: []
                    };
                } else {
                    currentChunk.lines.push(line);
                }
            }

            if (currentChunk.lines.length > 0 || currentChunk.name !== null) {
                chunks.push(currentChunk);
            }

            const nonEmptyLines = lines.filter(l => l.trim().length > 0);
            if (chunks.length === 0 && nonEmptyLines.length > 0) {
                return [{ name: 'chunk 1', lines: nonEmptyLines }];
            }

            let fallbackCount = 1;
            for (const chunk of chunks) {
                if (!chunk.name) {
                    chunk.name = `Chunk ${fallbackCount++}`;
                }
            }

            return chunks;
        }

        function parseLineToSlots(line) {
            const slots = [];
            let i = 0;
            let pendingNote = null;
            const len = line.length;

            function isSpace(ch) { return ch === ' ' || ch === '\t'; }

            while (i < len) {
                const ch = line[i];
                if (ch === '[') {
                    let j = i + 1;
                    while (j < len && line[j] !== ']') j++;
                    const noteText = line.slice(i + 1, j).trim();
                    const nextChar = (j + 1 < len) ? line[j + 1] : '';
                    if (nextChar && !isSpace(nextChar)) {
                        pendingNote = noteText;
                        i = j + 1;
                        continue;
                    } else {
                        slots.push({ note: noteText, word: '' });
                        i = j + 1;
                        continue;
                    }
                }
                if (isSpace(ch)) { i++; continue; }
                let start = i;
                while (i < len && !isSpace(line[i]) && line[i] !== '[') i++;
                const word = line.slice(start, i);
                const slot = { note: pendingNote || '', word };
                pendingNote = null;
                slots.push(slot);
            }

            if (pendingNote && pendingNote.length) {
                slots.push({ note: pendingNote, word: '' });
            }

            return slots;
        }

        function renderSlotsAsTwoRowTable(slots) {
            const table = document.createElement('table');
            table.className = 'line-table';
            const tbody = document.createElement('tbody');

            if (mode !== 'words') {
                const trNote = document.createElement('tr'); trNote.className = 'note-row';
                for (const slot of slots) {
                    const tdN = document.createElement('td');
                    const spanN = document.createElement('span'); spanN.textContent = slot.note || '';
                    tdN.appendChild(spanN);
                    trNote.appendChild(tdN);
                }
                tbody.appendChild(trNote);
            }

            const trWord = document.createElement('tr'); trWord.className = 'word-row';
            for (const slot of slots) {
                const tdW = document.createElement('td');
                const spanW = document.createElement('span'); spanW.textContent = slot.word || '';
                tdW.appendChild(spanW);
                trWord.appendChild(tdW);
            }
            tbody.appendChild(trWord);
            table.appendChild(tbody);
            return table;
        }

        function clearOutput() {
            document.getElementById('output').innerHTML = '';
        }

        function extractMetadataAndChunks(raw) {
            const text = raw.replace(/\r\n/g, "\n").replace(/\r/g, "\n").trim();
            if (!text) return { metadata: {}, chunks: [] };


            const lines = text.split('\n');
            const chunks = [];
            let metadata = {};
            let currentChunk = { name: null, lines: [] };
            let i = 0;
            let isMetadataPhase = true;


            while (i < lines.length) {
                const line = lines[i].trim();
                const isLabel = /^\[\![^\]]+\]$/.test(line);


                if (isLabel) {
                    const key = line.slice(2, -1).trim().toLowerCase();
                    const nextLine = lines[i + 1] || '';


                    if (isMetadataPhase && KNOWN_METADATA_KEYS.includes(key)) {
                        metadata[key] = nextLine.trim();
                        i += 2;
                        continue;
                    } else {
                        isMetadataPhase = false;
                        if (currentChunk.lines.length > 0 || currentChunk.name !== null) {
                            chunks.push(currentChunk);
                        }
                        currentChunk = {
                            name: key,
                            lines: []
                        };
                        i++;
                        continue;
                    }
                } else {
                    isMetadataPhase = false;
                    if (lines[i].trim().length > 0) {
                        currentChunk.lines.push(lines[i]);
                    }

                    i++;
                }
            }


            if (currentChunk.lines.length > 0 || currentChunk.name !== null) {
                chunks.push(currentChunk);
            }


            let fallbackCount = 1;
            for (const chunk of chunks) {
                if (!chunk.name) {
                    chunk.name = `Chunk ${fallbackCount++}`;
                }
            }


            return { metadata, chunks };
        }

        function renderMetadataHeader(meta) {
            const container = document.getElementById('metaHeader');
            container.innerHTML = '';
            if (!meta || Object.keys(meta).length === 0) return;


            const line1 = document.createElement('p');
            const title = meta.title || '';
            const author = meta.author || '';
            const ccli = meta.ccli ? `(CCLI # ${meta.ccli})` : '';
            const baseLine = [title, author].filter(Boolean).join(' - ') + (ccli ? ' ' + ccli : '');
            line1.textContent = baseLine;// + ' — Page ';
            // line1.classList.add('page-number-tag');



            const line2 = document.createElement('p');
            const key = meta.key ? `Key - ${meta.key}` : '';
            const bpm = meta.bpm ? `${meta.bpm} BPM` : '';
            const timing = meta.timing || '';
            line2.textContent = [key, bpm, timing].filter(Boolean).join(', ');


            const line3 = document.createElement('p');
            if (meta.roadmap) {
                line3.textContent = `Roadmap: ${meta.roadmap}`;
            }


            container.appendChild(line1);
            container.appendChild(line2);
            if (meta.roadmap) container.appendChild(line3);
        }

        function transposeChord(chord, fromKey, toKey, mode = 'guitar') {
            if (!fromKey || !toKey || chord.length === 0) return chord;

            const NOTE_ORDER_SHARP = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const FLAT_TO_SHARP = {
                'Db': 'C#', 'Eb': 'D#', 'Fb': 'E', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#', 'Cb': 'B',
                'E#': 'F', 'B#': 'C'
            };
            const SHARP_TO_FLAT = {
                'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb'
            };

            function normalize(note) {
                return FLAT_TO_SHARP[note] || note;
            }

            function extractRootPart(fullChord, useLeft) {
                if (!fullChord.includes('/')) return fullChord;
                const parts = fullChord.split('/');
                return useLeft ? parts[0] : parts[1];
            }

            function getSemitone(note) {
                return NOTE_ORDER_SHARP.indexOf(normalize(note));
            }

            // Choose target part of slash chord
            // Choose target part of slash chord
            let rawChord = chord;
            let target = chord;

            if (mode === 'guitar' && chord.includes('/')) {
                target = chord.split('/')[0];
            } else if (mode === 'bass' && chord.includes('/')) {
                target = chord.split('/')[1];
            }


            let base = target[0].toUpperCase();
            let accidental = '';
            let rest = '';

            if (target[1] === 'b' || target[1] === '#') {
                accidental = target[1];
                rest = target.slice(2);
            } else {
                rest = target.slice(1);
            }

            const rootNote = normalize(base + accidental);
            const rootIndex = getSemitone(rootNote);
            const fromIndex = getSemitone(normalize(fromKey));
            const toIndex = getSemitone(normalize(toKey));

            if (rootIndex === -1 || fromIndex === -1 || toIndex === -1) return chord;

            const semitoneShift = (toIndex - fromIndex + 12) % 12;
            const transposedIndex = (rootIndex + semitoneShift) % 12;
            let transposedRoot = NOTE_ORDER_SHARP[transposedIndex];

            // ✅ If user's selected key is flat, convert output to flats where applicable
            // ✅ If user's selected key is flat, convert output to flats where applicable
            const preferFlats = toKey.includes('b');
            if (userPrefersFlats && SHARP_TO_FLAT[transposedRoot]) {
                transposedRoot = SHARP_TO_FLAT[transposedRoot];
            }

            // ✅ Remove 'm' from minor chords in bass mode if no slash
            if (mode === 'bass' && !chord.includes('/') && rest.startsWith('m') && !rest.startsWith('maj')) {
                rest = rest.slice(1); // remove only the 'm'
            }

            return transposedRoot + rest;

        }



        function transposeLine(line, fromKey, toKey) {
            return line.replace(/\[([A-G][b#]?[^ \]]*)\]/g, (match, chord) => {
                const transposed = transposeChord(chord, fromKey, toKey);
                return `[${transposed}]`;
            });
        }



        function renderDocument(rawText) {
            lastLoadedText = rawText;
            clearOutput();


            const out = document.getElementById('output');
            const placeholder = document.getElementById('placeholder');
            if (placeholder) placeholder.remove();


            const { metadata, chunks } = extractMetadataAndChunks(rawText);
            renderMetadataHeader(metadata);

            const transposeSelect = document.getElementById('transposeSelect');

            if (metadata.key) {
                transposeSelect.disabled = false;

                // If user hasn't picked a key OR selected key is empty, default to file's key
                if (!userHasSetTranspose || transposeSelect.value === '') {
                    transposeKey = metadata.key.trim();
                    transposeSelect.value = transposeKey;
                }
            } else {
                // No key in file — reset and disable
                transposeKey = '';
                transposeSelect.value = '';
                transposeSelect.disabled = true;
                userHasSetTranspose = false;
            }



            // Normalize chunk map by name (case-insensitive)
            const chunkMap = {};
            for (const chunk of chunks) {
                chunkMap[chunk.name.toLowerCase()] = chunk;
            }

            let displayOrder = [];

            // Use roadmap if available
            if (metadata.roadmap) {
                const parts = metadata.roadmap.trim().split(/\s+/);
                for (const part of parts) {
                    const key = part.toLowerCase();
                    if (chunkMap[key]) {
                        displayOrder.push(chunkMap[key]);
                    }
                }
            } else {
                displayOrder = chunks;
            }

            // Render chunks in displayOrder
            for (const { name, lines } of displayOrder) {
                const section = document.createElement('section');
                section.className = 'chunk';

                const h2 = document.createElement('h2');
                h2.textContent = getDisplayName(name);
                section.appendChild(h2);

                for (const line of lines) {
                    // Apply transposition if needed
                    const slots = parseLineToSlots(line);

                    // Transpose note in each slot, not the whole line
                    if (metadata.key && (transposeSelect.value || mode === 'bass')) {
                        for (const slot of slots) {
                            if (slot.note) {
                                slot.note = transposeChord(slot.note, metadata.key, transposeSelect.value, mode);
                            }
                        }
                    }



                    const table = renderSlotsAsTwoRowTable(slots);
                    const wrapper = document.createElement('div');
                    wrapper.className = 'line-wrapper';
                    wrapper.appendChild(table);
                    section.appendChild(wrapper);
                }

                out.appendChild(section);
            }

        }

        const fileInput = document.getElementById('fileInput');
        fileInput.addEventListener('change', (e) => {
            const f = e.target.files && e.target.files[0];
            if (!f) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                const text = String(ev.target.result || '');
                userHasSetTranspose = false;

                renderDocument(text);
                fileInput.value = '';
            };
            reader.readAsText(f);
        });
    </script>
</body>

</html>
